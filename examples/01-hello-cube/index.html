<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hello Cube - Nova Engine</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background: #1a1a1a;
        color: #fff;
      }
      #canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 5px;
        font-size: 14px;
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 18px;
      }
      p {
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="info">
      <h1>ðŸŽ® Hello Cube - Nova Engine</h1>
      <p>Your first Nova Engine example!</p>
      <p><strong>Controls:</strong></p>
      <p>â€¢ Drag to rotate camera</p>
      <p>â€¢ Scroll to zoom</p>
      <p id="fps">FPS: 0</p>
    </div>
    <script type="module">
      console.log('ðŸš€ Nova Engine - Hello Cube Example');
      console.log('Initializing...');

      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl2');

      if (!gl) {
        alert('WebGL 2 not supported. Please use a modern browser.');
        throw new Error('WebGL 2 not supported');
      }

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resize();
      window.addEventListener('resize', resize);

      const vertexShaderSource = `#version 300 es
        precision highp float;
        in vec3 aPosition;
        in vec3 aNormal;
        uniform mat4 uModel;
        uniform mat4 uView;
        uniform mat4 uProjection;
        out vec3 vNormal;
        out vec3 vPosition;
        void main() {
          vec4 worldPos = uModel * vec4(aPosition, 1.0);
          vPosition = worldPos.xyz;
          vNormal = mat3(uModel) * aNormal;
          gl_Position = uProjection * uView * worldPos;
        }
      `;

      const fragmentShaderSource = `#version 300 es
        precision highp float;
        in vec3 vNormal;
        in vec3 vPosition;
        out vec4 fragColor;
        void main() {
          vec3 normal = normalize(vNormal);
          vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
          float diffuse = max(dot(normal, lightDir), 0.0);
          vec3 baseColor = vec3(0.3, 0.6, 1.0);
          vec3 color = baseColor * (0.3 + 0.7 * diffuse);
          fragColor = vec4(color, 1.0);
        }
      `;

      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vs = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fs = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      gl.useProgram(program);

      const vertices = new Float32Array([
        -1,-1,1,0,0,1, 1,-1,1,0,0,1, 1,1,1,0,0,1, -1,1,1,0,0,1,
        -1,-1,-1,0,0,-1, -1,1,-1,0,0,-1, 1,1,-1,0,0,-1, 1,-1,-1,0,0,-1,
        -1,1,-1,0,1,0, -1,1,1,0,1,0, 1,1,1,0,1,0, 1,1,-1,0,1,0,
        -1,-1,-1,0,-1,0, 1,-1,-1,0,-1,0, 1,-1,1,0,-1,0, -1,-1,1,0,-1,0,
        1,-1,-1,1,0,0, 1,1,-1,1,0,0, 1,1,1,1,0,0, 1,-1,1,1,0,0,
        -1,-1,-1,-1,0,0, -1,-1,1,-1,0,0, -1,1,1,-1,0,0, -1,1,-1,-1,0,0
      ]);

      const indices = new Uint16Array([
        0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11,
        12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23
      ]);

      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const ibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      const posLoc = gl.getAttribLocation(program, 'aPosition');
      const normLoc = gl.getAttribLocation(program, 'aNormal');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 24, 0);
      gl.enableVertexAttribArray(normLoc);
      gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 24, 12);

      const uModel = gl.getUniformLocation(program, 'uModel');
      const uView = gl.getUniformLocation(program, 'uView');
      const uProjection = gl.getUniformLocation(program, 'uProjection');

      function perspective(fov, aspect, near, far) {
        const f = 1 / Math.tan(fov / 2);
        const nf = 1 / (near - far);
        return new Float32Array([f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,2*far*near*nf,0]);
      }

      function lookAt(eye, center, up) {
        const z = [eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]];
        const zLen = Math.sqrt(z[0]*z[0]+z[1]*z[1]+z[2]*z[2]);
        z[0]/=zLen; z[1]/=zLen; z[2]/=zLen;
        const x = [up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0]];
        const xLen = Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);
        x[0]/=xLen; x[1]/=xLen; x[2]/=xLen;
        const y = [z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]];
        return new Float32Array([x[0],y[0],z[0],0,x[1],y[1],z[1],0,x[2],y[2],z[2],0,
          -(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]),-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]),
          -(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]),1]);
      }

      function rotateY(angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        return new Float32Array([c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1]);
      }

      let cameraDistance = 5, cameraRotation = 0;
      let isDragging = false, lastX = 0;

      canvas.addEventListener('mousedown', (e) => { isDragging = true; lastX = e.clientX; });
      canvas.addEventListener('mousemove', (e) => {
        if (isDragging) { cameraRotation += (e.clientX - lastX) * 0.01; lastX = e.clientX; }
      });
      canvas.addEventListener('mouseup', () => isDragging = false);
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        cameraDistance = Math.max(2, Math.min(10, cameraDistance + e.deltaY * 0.01));
      });

      gl.enable(gl.DEPTH_TEST);
      let lastTime = 0, frameCount = 0, fpsUpdateTime = 0;

      function animate(time) {
        time *= 0.001;
        const deltaTime = time - lastTime;
        lastTime = time;

        frameCount++;
        fpsUpdateTime += deltaTime;
        if (fpsUpdateTime >= 0.5) {
          document.getElementById('fps').textContent = `FPS: ${Math.round(frameCount / fpsUpdateTime)}`;
          frameCount = 0;
          fpsUpdateTime = 0;
        }

        gl.clearColor(0.1, 0.1, 0.15, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const aspect = canvas.width / canvas.height;
        const projMatrix = perspective(Math.PI / 4, aspect, 0.1, 100);
        const camX = Math.sin(cameraRotation) * cameraDistance;
        const camZ = Math.cos(cameraRotation) * cameraDistance;
        const viewMatrix = lookAt([camX, 2, camZ], [0, 0, 0], [0, 1, 0]);
        const modelMatrix = rotateY(time * 0.5);

        gl.uniformMatrix4fv(uProjection, false, projMatrix);
        gl.uniformMatrix4fv(uView, false, viewMatrix);
        gl.uniformMatrix4fv(uModel, false, modelMatrix);

        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        requestAnimationFrame(animate);
      }

      console.log('âœ… Ready!');
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
